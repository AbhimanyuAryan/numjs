<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';

var iota = require('iota-array');
var ndarray = require('ndarray');
var cwise = require('cwise');
var ops = require('ndarray-ops');
var errors = require('./errors');
var gemm = require('ndarray-gemm');
var ndFFT = require('ndarray-fft');
var ndPool = require('typedarray-pool');
var _ = require('lodash');


var DTYPES = {
    int8: Int8Array,
    int16: Int16Array,
    int32: Int32Array,
    uint8: Uint8Array,
    uint16: Uint16Array,
    uint32: Uint32Array,
    float32: Float32Array,
    float64: Float64Array
};

function isNumber(value) {
    return typeof value === 'number';
}
function isString(value) {
    return typeof value == 'string';
}

function initNativeArray(shape, i){
    i = i || 0;
    var c = shape[i]|0;
    if(c &lt;= 0) {
        return [];
    }
    var result = new Array(c), j;
    if(i === shape.length-1) {
        for(j=0; j&lt;c; ++j) {
            result[j] = 0;
        }
    } else {
        for(j=0; j&lt;c; ++j) {
            result[j] = initNativeArray(shape, i+1);
        }
    }
    return result;
}

var doUnpack = cwise({
    args: ['array', 'scalar', 'index'],
    body: function unpackCwise(arr, a, idx) {
        var v = a, i;
        for(i=0;i&lt;idx.length-1;++i) {
            v=v[idx[i]];
        }
        v[idx[idx.length-1]]=arr;
    }
});

function unpackArray(arr) {
    var result = initNativeArray(arr.shape, 0);
    doUnpack(arr, result);
    return result;
}

function size(shape){
    var s = 1;
    for (var i = 0; i &lt; shape.length; i++){
        s *= shape[i];
    }
    return s;
}

//function locateIndex(index, shape){
//    var max = size(shape);
//    if (index &lt; 0 || index >= max){
//        throw new errors.ValueError('index must be gt 0 and lt "'+max+'"');
//    }
//    return []
//        .concat(shape)
//        .reverse()
//        .map(function(d){
//            var i = index % d;
//            index -= i;
//            index /= d;
//            return i;
//        })
//        .reverse();
//}

function _dim(x) {
    var ret = [];
    while(typeof x === 'object') { ret.push(x.length); x = x[0]; }
    return ret;
}

function dim(x) {
    var y,z;
    if(typeof x === 'object') {
        y = x[0];
        if(typeof y === 'object') {
            z = y[0];
            if(typeof z === 'object') {
                return _dim(x);
            }
            return [x.length,y.length];
        }
        return [x.length];
    }
    return [];
}

function getType(dtype){
    return _.isFunction(dtype)? dtype: (DTYPES[dtype] || Array);
}

function haveSameShape(shape1, shape2){
    return size(shape1) === size(shape2) &amp;&amp; _.every(_.zip(shape1, shape2),function(pair){ return pair[0] === pair[1]; });
}

function broadcast(shape1, shape2) {
    if (_.isEmpty(shape1) || _.isEmpty(shape2)){
        return;
    }
    var reversed1 = [].concat(shape1).reverse();
    var reversed2 = [].concat(shape2).reverse();
    var bcst = _
        .chain(_.zip(reversed1, reversed2))
        .map(function(pair){
            if (!pair[0] || pair[0] === 1){ return pair[1]; }
            if (!pair[1] || pair[1] === 1){ return pair[0]; }
            if (pair[0] === pair[1]){ return pair[0]; }
        })
        .reverse()
        .value();
    return _.every(bcst)? bcst: undefined;
}

/**
 * Multidimensional container of items of the same type and size.
 *
 * The number of dimensions and items in an array is defined by its shape, which is a tuple of N positive
 * integers that specify the sizes of each dimension. The type of items in the array is specified by a separate
 * data-type object (dtype), one of which is associated with each NdArray.
 */
var NdArray = function NdArray(data, shape, stride, offset){
    if (arguments.length === 1){
        this.selection = data;
    }
    else if (arguments.length === 0){
        throw new errors.ValueError('Required argument \'data\' not found');
    }
    else {
        this.selection = ndarray(data, shape, stride, offset);
    }
    Object.defineProperty(this, "size",{
        get: function() {
            return this.selection.size;
        }.bind(this)
    });
    Object.defineProperty(this, "shape",{
        get: function() {
            return this.selection.shape;
        }.bind(this)
    });
    Object.defineProperty(this, "ndim",{
        get: function() {
            return this.selection.shape.length;
        }.bind(this)
    });
    Object.defineProperty(this, "dtype",{
        get: function() {
            return this.selection.dtype;
        }.bind(this),
        set: function (dtype) {
            var T = getType(dtype);
            this.selection = ndarray(new T(this.selection.data), this.selection.shape, this.selection.stride, this.selection.offset);
        }.bind(this)
    });
};

NdArray.prototype.pick = function(){
    return new NdArray(this.selection.pick.apply(this.selection, arguments));
};

NdArray.prototype.lo = function () {
    return new NdArray(this.selection.lo.apply(this.selection, arguments));
};

NdArray.prototype.hi = function () {
    return new NdArray(this.selection.hi.apply(this.selection, arguments));
};

NdArray.prototype.add = function(value){
    var shape = this.shape;
    var type = getType(this.dtype);
    var result = this.clone();
    if (isNumber(value)){
        ops.addseq(result.selection, value);
        return result;
    }
    if (value instanceof NdArray){
        ops.addeq(result.selection, value.selection);
        return result;
    }
    throw new errors.ValueError('value must be a number or an array');
};


/**
 * Return the maximum value of the array
 */
NdArray.prototype.max = function () {
    if (this.selection.size === 0){
        return null;
    }
    return ops.sup(this.selection);
};
function max(array){
    return createArray(array).max();
}


/**
 * Return the minimum value of the array
 */
NdArray.prototype.min = function () {
    if (this.selection.size === 0){
        return null;
    }
    return ops.inf(this.selection);
};
function min(array){
    return createArray(array).min();
}


/**
 * Return true if two arrays have the same shape and elements, false otherwise.
 * @param {(Array|NdArray)} array
 * @returns {boolean}
 */
NdArray.prototype.equal = function(array){
    array = createArray(array);
    if (this.size !== array.size || this.ndim !== array.ndim){
        return false;
    }
    var d = this.ndim;
    for (var i=0;i&lt;d; i++){
        if (this.shape[i] !== array.shape[i]){
            return false;
        }
    }

    return ops.all(ops.eqeq(this.selection, array.selection));
};

/**
 * Return true if two arrays have the same shape and elements, false otherwise.
 * @param {(Array|NdArray)} array1
 * @param {(Array|NdArray)} array2
 * @returns {boolean}
 */
function equal(array1, array2){
    return createArray(array1).equal(array2);
}

NdArray.prototype.mul = function(value){
    var type = getType(this.dtype);
    var result, shape;
    if (isNumber(value)){
        shape = this.shape;
        result = new NdArray(new type(size(shape)), shape);
        ops.muls(result.selection, this.selection, value);
        return result;
    }
    if (!(value instanceof NdArray)){
        throw new Error('value must be a scalar or an array');
    }
    shape = broadcast(this.shape, value.shape);
    if (!shape){
        throw new errors.ValueError('dimensions are not broadcastable');
    }
    result = new NdArray(new type(size(shape)), shape);
    ops.mul(result.selection, this.selection, value.selection);
    return result;
};
function mul(a,b){
    return createArray(a).mul(b);
}

NdArray.prototype.flatten = function () {
    if (this.shape.length === 1){
        // already flattened
        return new NdArray(this.selection)
    }
    var T = getType(this.dtype);
    var arr = _.flattenDeep(this.tolist());
    if (!(arr instanceof T)){
        arr = new T(arr);
    }
    return new NdArray(arr, [this.size]);
};

function flatten(array){
    return createArray(array).flatten();
}

NdArray.prototype.reshape = function(shape){
    if (arguments.length === 0) {
        throw new errors.ValueError('function takes at least one argument (0 given)');
    }
    if (arguments.length === 1 &amp;&amp; isNumber(shape)){
        shape = [shape];
    }
    if (arguments.length > 1){
        shape = arguments;
    }
    var newSize = size(shape);
    if (this.size !== newSize){
        throw new errors.ValueError('total size of new array must be unchanged');
    }

    var selfShape = this.selection.shape,
        selfOffset = this.selection.offset,
        selfStride = this.selection.stride,
        selfDim = selfShape.length;

    var d = shape.length, stride, offset;
    if (selfDim === d){
        var sameShapes = true;
        for (var i=0; i&lt;d; ++i) {
            if (selfShape[i] !== shape[i]){
                sameShapes = false;
                break;
            }
        }
        if (sameShapes){
            return new NdArray(this.selection.data, selfShape, selfStride, selfOffset);
        }
    }
    else if (selfDim === 1){
        // 1d view
        stride = new Array(d);
        for(var i=d-1, sz=1; i>=0; --i) {
            stride[i] = sz;
            sz *= shape[i];
        }
        offset = selfOffset;
        for(var i=0; i&lt;d; ++i) {
            if(stride[i] &lt; 0) {
                offset -= (shape[i]-1)*stride[i];
            }
        }
        return new NdArray(this.selection.data, shape, stride, offset);
    }

    var minDim = Math.min(selfDim, d);
    var areCompatible = true;
    for(var i=0; i&lt;minDim; i++) {
        if (selfShape[i] !== shape[i]){
            areCompatible = false;
            break;
        }
    }
    if (areCompatible){
        stride = new Array(d);
        for (var i=0;i&lt;d;i++){
            stride[i] = selfStride[i] || 1;
        }
        offset = selfOffset;
        return new NdArray(this.selection.data, shape, stride, offset);
    }
    return this.flatten().reshape(shape);
};

//NdArray.prototype.dtype = function(dtype){
//    if (!arguments.length){
//        return this.selection.dtype;
//    }
//    var type = getType(dtype);
//    if (type === getType(this.selection.dtype)){
//        return;
//    }
//    this.selection = ndarray(new type(this.selection.data), this.shape);
//    return this;
//};

NdArray.prototype.tolist = function(){
    return unpackArray(this.selection);
};


NdArray.prototype.toString = function(){
    var max = this.max();
    var nChars = String(max).length;

    var reg1 = /\]\,(\s*)\[/g,
        spacer1  = '],\n$1      [',
        reg3 = /\]\,(\s+)...\,(\s+)\[/g,
        spacer3  = '],\n$2       ...\n$2      [',
        reg2 = /\[\s+\[/g,
        spacer2  = '[[';

    function formatArray(k, v){
        if (isString(v)){ return v; }
        if (isNumber(v)){
            var s = String(v);
            return new Array(Math.max(0, nChars - s.length +2)).join(' ') + s;
        }
        k = k || 0;
        var arr;
        if (v.length>7){
            arr = [].concat(v.slice(0,2), [' ...'], v.slice(v.length - 2));
        }
        else {
            arr = v;
        }
        return new Array(k+1).join(' ')+'[' + arr.map(function(i, ii){ return formatArray(ii === 0 &amp;&amp; k === 0? 1: k+1, i); }).join(',') + ']';
    }


    var base = JSON
        .stringify(this.tolist(), formatArray)
        .replace(reg1, spacer1)
        .replace(reg2, spacer2)
        .replace(reg2, spacer2)
        .replace(reg3, spacer3)
        .slice(2,-1);
    switch (this.dtype){
        case 'array':
            return 'array([' + base + ')';
        default:
            return 'array([' + base + ', dtype=' + this.dtype + ')';
    }
};
NdArray.prototype.inspect = NdArray.prototype.toString;

NdArray.prototype.toJSON = function () {
    return JSON.stringify(this.tolist());
};

NdArray.prototype.clone = function () {
    var s = this.selection,
        clone = ndarray(s.data.slice(), s.shape, s.stride, s.offset);
    return new NdArray(clone);
};

NdArray.prototype.exp = function(){
    var arr = this.clone() ;
    ops.expeq(arr.selection);
    return arr;
};

NdArray.prototype.sum = function(){
    return ops.sum(this.selection);
};

NdArray.prototype.mean = function(){
    return ops.sum(this.selection) / size(this.shape);
};

NdArray.prototype.std = function(){
    var squares = this.clone();
    ops.powseq(squares.selection, 2);
    var mean =  this.mean(),
        variance = Math.abs(ops.sum(squares.selection) / size(this.shape) - mean * mean);
    return variance > 0? Math.sqrt(variance): 1;
};

NdArray.prototype.transpose = function (axes){
    if (arguments.length === 0) {
        axes = iota(this.shape.length).reverse();
    }
    else if (arguments.length > 1){
        axes = arguments;
    }
    return new NdArray(this.selection.transpose.apply(this.selection, axes));
};

NdArray.prototype.neg = function(){
    var c = this.clone();
    ops.neg(c.selection, this.selection);
    return c;
};

NdArray.prototype.get = function(){
    return this.selection.get.apply(this.selection, arguments);
};

NdArray.prototype.set = function(){
    return this.selection.set.apply(this.selection, arguments);
};


NdArray.prototype.iteraxis = function(axis, cb){
    var shape = this.shape;
    if (axis === -1){
        axis = shape.length - 1;
    }
    if (axis &lt; 0 || axis > shape.length -1){
        throw new errors.ValueError('invalid axis');
    }
    for (var i=0; i&lt;shape[axis];i++){
        var loc = _.map(_.range(axis + 1), function(ii){ return ii === axis? i: null; });
        var subArr = this.selection.pick.apply(this.selection, loc);
        var xi = createArray(unpackArray(subArr), this.dtype);
        cb(xi, i);
    }
};

function createArray(arr, dtype){
    if (arr instanceof NdArray){ return arr; }
    var T = getType(dtype);
    if (isNumber(arr)){
        if (T !== Array){
            return new NdArray(new T([arr]), [1]);
        }
        else {
            return new NdArray([arr], [1]);
        }

    }

    var shape = dim(arr);
    if (shape.length > 1){
        arr = _.flattenDeep(arr);
    }
    if (!(arr instanceof T)){
        arr = new T(arr);
    }
    return new NdArray(arr, shape);
}

/**
 * Return evenly spaced values within a given interval.
 *
 * @param {int} [start=0] - Start of interval. The interval includes this value.
 * @param {int} stop - End of interval. The interval does not include this value.
 * @param {int} [step=1] - Spacing between values. The default step size is 1. If step is specified, start must also be given.
 * @param {(String|Object)} [dtype=Array] The type of the output array.
 *
 * @return {NdArray} Array of evenly spaced values.
 */
function arange(start, stop, step, dtype) {
    if (arguments.length === 1){
        stop  = start;
        start = 0;
        step = 1
    }
    else if (arguments.length === 2 &amp;&amp; isNumber(stop)){
        step = 1
    }
    else if (arguments.length === 2){
        dtype = stop;
        stop = start;
        start = 0;
        step = 1;
    }
    else if (arguments.length === 3 &amp;&amp; !isNumber(step)){
        dtype = step;
        step = 1;
    }
    var result = [], i=0;
    while (start &lt; stop){
        result[i++] = start;
        start += step;
    }
    return createArray(result, dtype);
}

/**
 * Return a new array of given shape and type, filled with zeros.
 *
 * @param {(Array|int)} shape - Shape of the new array, e.g., [2, 3] or 2.
 * @param {(String|Object)}  [dtype=Array]  The type of the output array.
 *
 * @return {NdArray} Array of zeros with the given shape and dtype
 */
function zeros(shape, dtype){
    if (isNumber(shape) &amp;&amp; shape >=0){
        shape = [shape];
    }
    else if (!_.isArray(shape)){
        throw new Error('shape must be a positive integer or an array');
    }
    var s = size(shape);
    var type = getType(dtype);
    var arr =  new NdArray(new type(s), shape);
    ops.assigns(arr.selection, 0);
    return arr;
}

/**
 * Return a new array of given shape and type, filled with ones.
 *
 * @param {(Array|int)} shape - Shape of the new array, e.g., [2, 3] or 2.
 * @param {(String|Object)}  [dtype=Array] - The type of the output array.
 *
 * @return {NdArray} Array of ones with the given shape and dtype
 */
function ones(shape, dtype){
    if (isNumber(shape) &amp;&amp; shape >=0){
        shape = [shape];
    }
    else if (!_.isArray(shape)){
        throw new Error('shape must be a positive integer or an array');
    }
    var s = size(shape);
    var type = getType(dtype);
    var arr =  new NdArray(new type(s), shape);
    ops.assigns(arr.selection, 1);
    return arr;
}



function random(shape, dtype){
    if (isNumber(shape) &amp;&amp; shape >=0){
        shape = [shape];
    }
    else if (!_.isArray(shape)){
        throw new Error('shape must be a positive integer or an array');
    }
    var s = size(shape);
    var type = getType(dtype);
    var arr =  new NdArray(new type(s), shape);
    ops.random(arr.selection);
    return arr;
}

function softmax(x){
    var e = (x instanceof NdArray)? x.exp(): createArray(x).exp();
    var se = e.sum(); // scalar
    ops.divseq(e.selection, se);
    return e;
}

function exp(x){
    if (isNumber(x)){ return Math.exp(x); }
    return (x instanceof NdArray)? x.exp() : createArray(x).exp();
}

function sum(x){
    if (isNumber(x)){ return x; }
    return (x instanceof NdArray)? x.sum() : createArray(x).sum();
}

function mean(x){
    if (isNumber(x)){ return x; }
    return (x instanceof NdArray)? x.mean() : createArray(x).mean();
}

function std(x){
    if (isNumber(x)){ return 0; }
    return (x instanceof NdArray)? x.std() : createArray(x).std();
}


var doSigmoid = cwise({
    args: ['array', 'scalar'],
    body: function sigmoidCwise(a, t) {
        a = a &lt; -30? 0: a > 30? 1: 1 / (1 + Math.exp(-1 * t * a));
    }
});
function sigmoid(x, t){
    var s = (x instanceof NdArray)? x.clone(): createArray(x);
    t = t || 1;
    doSigmoid(s.selection, t);
    return s;
}

var doClip = cwise({
    args: ['array', 'scalar', 'scalar'],
    body: function clipCwise(a, min, max) {
        a = Math.min(Math.max(min, a), max);
    }
});

function clip(x, min, max){
    var s = (x instanceof NdArray)? x.clone(): createArray(x);
    doClip(s.selection, min, max);
    return s;
}

var doLeakyRelu = cwise({
    args: ['array', 'scalar'],
    body: function leakyReluCwise(xi, alpha) {
        xi = Math.max(alpha * xi, xi);
    }
});

function leakyRelu(x, alpha){
    alpha = alpha || 1e-3;
    var s = (x instanceof NdArray)? x.clone(): createArray(x);
    doLeakyRelu(s.selection, alpha);
    return s;
}


var doTanh = cwise({
    args: ['array'],
    body: function tanhCwise(xi) {
        xi = (Math.exp(2*xi) - 1) / (Math.exp(2*xi) + 1);
    }
});

function tanh(x){
    var s = createArray(x).clone();
    doTanh(s.selection);
    return s;
}

function dot(a,b){
    var xa = (a instanceof NdArray)? a: createArray(a);
    var xb = (b instanceof NdArray)? b: createArray(b);
    var xaShape = xa.shape,
        xbShape = xb.shape;
    var shape, c, rxa, rxb, type = getType(xa.dtype);

    if (xaShape.length === 2 &amp;&amp; xbShape.length === 2){
        shape = [xaShape[0], xbShape[1]];
        c = new NdArray(new type(size(shape)), shape);
        gemm(c.selection, xa.selection, xb.selection);
        return c;
    }
    else if (xaShape.length === 1 &amp;&amp; xbShape.length === 2){
        shape = [1, xbShape[1]];
        rxa = xa.reshape([xaShape[0], 1]).transpose();
        c = new NdArray(new type(size(shape)), shape);
        gemm(c.selection, rxa.selection, xb.selection);
        return c.flatten();
    }
    else if (xaShape.length === 1 &amp;&amp; xbShape.length === 1 &amp;&amp; xaShape[0] === xbShape[0]){
        shape = [1, 1];
        rxa = xa.reshape([xaShape[0], 1]).transpose();
        rxb = xb.reshape([xbShape[0], 1]);
        c = new NdArray(new type(size(shape)), shape);
        gemm(c.selection, rxa.selection, rxb.selection);
        return c.reshape([1]);
    }
    else {
        throw new errors.NotImplementedError();
        //throw new errors.ValueError('shapes ('+xaShape[0]+',) and ('+xbShape[0]+',) not aligned: '+xaShape[0]+ '(dim 0) != '+xbShape[0]+' (dim 0)');
    }
}


function concatenate(arrays, dtype){
//    if (_.some(arrays, function(a){return  isNumber(a); })){
//        throw new errors.ValueError('zero-dimensional arrays cannot be concatenated');
//    }

    var c = _
        .chain(arrays)
        .map(function(a){ return (a instanceof NdArray)? a.tolist(): isNumber(a)? [a] : a  ; })
        .reduce(function(m, data){
            if (m === null){ return data; }

            var mShape = dim(m);
            var dShape = dim(data);
            if (mShape.length !== dShape.length){
                throw new errors.ValueError('all the input arrays must have same number of dimensions');
            }

            if (mShape.length === 1 &amp;&amp; dShape.length === 1){
                return m.concat(data);
            }
            if ((mShape.length === 2 &amp;&amp; dShape.length === 2 &amp;&amp; mShape[0] === dShape[0]) ||
                (mShape.length === 1 &amp;&amp; dShape.length === 2 &amp;&amp; mShape[0] === dShape[0]) ||
                (mShape.length === 2 &amp;&amp; dShape.length === 1 &amp;&amp; mShape[0] === dShape[0])){
                return _.map(_.zip(m, data), function (d) { return [].concat.apply([],d); });
            }
            if ((mShape.length === 3 &amp;&amp; dShape.length === 3 &amp;&amp; mShape[0] === dShape[0] &amp;&amp; mShape[1] === dShape[1]) ||
                (mShape.length === 2 &amp;&amp; dShape.length === 3 &amp;&amp; mShape[0] === dShape[0] &amp;&amp; mShape[1] === dShape[1]) ||
                (mShape.length === 3 &amp;&amp; dShape.length === 2 &amp;&amp; mShape[0] === dShape[0] &amp;&amp; mShape[1] === dShape[1])){
                return _.map(_.zip(m, data), function (d) {
                    return _.map(_.zip.apply(null, d), function (dd){
                        return [].concat.apply([],dd);
                    });
                });
            }
            throw new errors.ValueError('cannot concatenate  "'+mShape+'" with "'+dShape+'"');
        }, null)
        .value();
    return createArray(c, dtype);
}

function transpose(x, axes){
    return createArray(x).transpose(axes);
}

function add(a,b){
    return createArray(a).add(b);
}

function neg(x){
    return createArray(x).neg();
}




module.exports = {
    dtypes: DTYPES,
    NdArray: NdArray,
    ndarray: ndarray,
    array: createArray,
    arange: arange,
    zeros: zeros,
    ones: ones,
    flatten: flatten,
    random: random,
    softmax: softmax,
    sigmoid: sigmoid,
    leakyRelu: leakyRelu,
    tanh: tanh,
    clip: clip,
    exp: exp,
    sum: sum,
    mean: mean,
    std: std,
    dot: dot,
    add: add,
    neg: neg,
    mul: mul,
    size: size,
    equal: equal,
    max: max,
    min: min,
    concatenate: concatenate,
    transpose: transpose,
    errors: errors,
    broadcast: broadcast,
    //locate: locateIndex,
    //cwise: cwise,
    fft: ndFFT,
    ops: ops,
    pool: ndPool
};

_.forEach(DTYPES, function(v,k){
    module.exports[k] = function(arr){ return createArray(arr, k); };
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#arange">arange</a></li><li><a href="global.html#equal">equal</a></li><li><a href="global.html#NdArray">NdArray</a></li><li><a href="global.html#ones">ones</a></li><li><a href="global.html#zeros">zeros</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Feb 14 2016 19:38:32 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
